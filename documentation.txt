Getting data via API
You can receive data automatically using the API. To do this, you need to write a command /API in the bot and get your personal token. Initially, it will have 100 free requests that will allow testing the system. When they end, money will begin to spend money from your balance.

The price of the request depends on the type of request and on the specified search limit. By default, the limit is 100, with such a limit, most requests will cost 0.003 $.

The price calculation formula in dollars is as follows:

(5 + sqrt(Limit * Complexity)) / 5000
Limit is a search limit that you specified (for example, 100).
Complexity is a parameter reflecting the number of single searches that must be performed for your request.
If the request consists of several words, then they are looking for in all possible rearrangements, and therefore the complexity depends on the number of words in your request. Here is an example of calculating complexity:

1 word: Complexity = 1
2 words: Complexity = 5
3 words: Complexity = 16
More than 3 words: Complexity = 40
Moreover, the following elements are not considered the words:

Dates
Lines are shorter than 4 characters
Numbers shorter than 6 characters
If you need to avoid dividing the request into words by spaces, use double quotation marks for accurate search, as described below.

Note: Limit on the frequency of requests from one IP - 1 request per second. If you need to execute more queries, you can combine several requests into one.
Request parameters
Parameter	Description
'token'	The token that you receive after executing the command /api.
'request'	A line with your request or an array of lines with several requests.
'limit'	Search limit (default 100). The number is from 100 to 10,000. It determines the number of returned results and the search range in the database.
'lang'	The language code on which there will be the results of the request (by default en ).
'type'	Type of reporting: json, short, html (By default) json).
'bot_name'	The name of the bot in the format @name (it is necessary to indicate if the bot does not apply to the main group of mirrors).
Examples of requests
Example 1:

{"token":"987654321:b42vAQjW", "request":"google"}
        
Example 2:

{"token":"987654321:b42vAQjW", "request":"Petya Ivanov ", "lang": "ru"}
        
Example 3:

{"token":"987654321:b42vAQjW", "request":"example@gmail.com", "limit": 10}
        
Example 4:

{"token":"987654321:b42vAQjW", "request":"Elon Reeve Musk", "limit": 100, "lang":"ru"}
        
Example 5:

{"token":"987654321:b42vAQjW", "request":"example@gmail.com\nElon Reeve Musk"}
        
Example 6:

{"token":"987654321:b42vAQjW", "request":["example@gmail.com","Elon Reeve Musk"]}
        
Пример кода (Python)
Пример использования API на языке Python:

import requests

data = {"token":"987654321:Vg41g0qY", "request":"test request", "limit": 100, "lang":"ru"}
url = 'https://leakosintapi.com/'
response = requests.post(url, json=data)
print(response.json())
        
Please note: The query data is sent in JSON format. If you send in the form of a request parameters, you will get a 501 error.

An example of a telegram bout based on the API:

import requests
from random import randint
try:
    import telebot
    from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
except ModuleNotFoundError:
    input("There is no necessary library. Complete the command line command: PIP Install Pytelegrambotapi")

url = "https://leakosintapi.com/"
bot_token = "" #Insert here the token received from @botfather
api_token = ""  #Insert here the token received from Leakosint
lang = "ru"
limit = 300

#In this function, you can check whether the user has access to
def user_access_test(user_id):
    return(True)

#Function for generating reports
cash_reports = {}
def generate_report(query, query_id):
    global cash_reports, url, bot_token, api_token, limit, lang
    data =  {"token":api_token, "request":query.split("\n")[0], "limit": limit, "lang":lang}
    response = requests.post(url, json=data).json()
    print(response)
    if "Error code" in response:
        print("Error:"+response["Error code"])
        return(None)
    cash_reports[str(query_id)] = []
    for database_name in response["List"].keys():
        text = [f"<b>{database_name}</b>",""]
        text.append(response["List"][database_name]["InfoLeak"]+"\n")
        if database_name!="No results found":
            for report_data in response["List"][database_name]["Data"]:
                for column_name in report_data.keys():
                    text.append(f"<b>{column_name}</b>:  {report_data[column_name]}")
                text.append("")
        text = "\n".join(text)
        if len(text)>3500:
            text = text[:3500]+text[3500:].split("\n")[0]+"\n\nSome data did not fit this message"
        cash_reports[str(query_id)].append(text)
    return(cash_reports[str(query_id)])

#Function for creating an inline keyboard
def create_inline_keyboard(query_id, page_id, count_page):
    markup = InlineKeyboardMarkup()
    if page_id<0:
        page_id=count_page
    elif page_id>count_page-1:
        page_id=page_id%count_page
    if count_page==1:
        return markup
    markup.row_width = 3
    markup.add(InlineKeyboardButton(text = "<<", callback_data=f"/page {query_id} {page_id-1}"),
               InlineKeyboardButton(text = f"{page_id+1}/{count_page}", callback_data="page_list"),
               InlineKeyboardButton(text = ">>", callback_data=f"/page {query_id} {page_id+1}"))
    return markup

bot = telebot.TeleBot(bot_token)
@bot.message_handler(commands=["start"])
def send_welcome(message):
    bot.reply_to(message, "Hello! I am a telegram-boot that can search for databases.", parse_mode="Markdown")

@bot.message_handler(func=lambda message: True)
def echo_message(message):
    user_id = message.from_user.id
    if not(user_access_test(user_id)):
        bot.send_message(message.chat.id, "You have no access to the bot")
        return()
    if message.content_type == "text":
        query_id = randint(0,9999999)
        report = generate_report(message.text,query_id)
        markup = create_inline_keyboard(query_id,0,len(report))
        if report==None:
            bot.reply_to(message, "The bot does not work at the moment.", parse_mode="Markdown")
        try:
            bot.send_message(message.chat.id, report[0], parse_mode="html", reply_markup=markup) #, reply_markup=markup
        except telebot.apihelper.ApiTelegramException:
            bot.send_message(message.chat.id, text = report[0].replace("<b>","").replace("</b>",""), reply_markup=markup)
        
@bot.callback_query_handler(func=lambda call: True)
def callback_query(call: CallbackQuery):
    global cash_reports
    if call.data.startswith("/page "):
        query_id, page_id = call.data.split(" ")[1:]
        if not(query_id in cash_reports):
            bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id, text="The results of the request have already been deleted")
        else:
            report = cash_reports[query_id]
            markup = create_inline_keyboard(query_id,int(page_id),len(report))
            try:
                bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id, text=report[int(page_id)], parse_mode="html", reply_markup=markup)
            except telebot.apihelper.ApiTelegramException:
                bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id, text=report[int(page_id)].replace("<b>","").replace("</b>",""), reply_markup=markup)
while True:
    try:
        bot.polling()
    except:
        pass
        